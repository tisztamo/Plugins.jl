<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Reference · Plugins.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="Plugins.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">Plugins.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction</a></li><li><a class="tocitem" href="../gettingstarted/">Getting Started</a></li><li><a class="tocitem" href="../guide/">Guide</a></li><li><a class="tocitem" href="../repo/">Repo</a></li><li class="is-active"><a class="tocitem" href>Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Reference</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/tisztamo/Plugins.jl/blob/master/docs/src/reference.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Reference"><a class="docs-heading-anchor" href="#Reference">Reference</a><a id="Reference-1"></a><a class="docs-heading-anchor-permalink" href="#Reference" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="Plugins.FieldSpec" href="#Plugins.FieldSpec"><code>Plugins.FieldSpec</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">FieldSpec(name, type::Type, constructor::Union{Function, DataType} = type)</code></pre><p>Field specification for plugin-assembled types.</p><p>Note that every field of an assembled type will be constructed with the same arguments.  Possibly The constructor will be called when the system </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tisztamo/Plugins.jl/blob/d108fbb9fe3b7603131db4c238c2f44514723161/src/assembled_types.jl#LL49-L56">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Plugins.HookList" href="#Plugins.HookList"><code>Plugins.HookList</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">HookList{TNext, THandler, TPlugin}</code></pre><p>Provides fast, inlinable call to the implementations of a specific hook.</p><p>You can get a HookList by calling <code>hooklist()</code> directly, or using <code>hooks()</code>.</p><p>The <code>HookList</code> can be called with arbitrary number of extra arguments. If any of the plugins referenced in the list fails to handle the extra arguments, the call will raise a <code>MethodError</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tisztamo/Plugins.jl/blob/d108fbb9fe3b7603131db4c238c2f44514723161/src/Plugins.jl#LL114-L123">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Plugins.ImmutableStruct" href="#Plugins.ImmutableStruct"><code>Plugins.ImmutableStruct</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct ImmutableStruct &lt;: TemplateStyle end</code></pre><p>Plugin-assembled types marked as <code>ImmutableStruct</code> will be generated as a <code>struct</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tisztamo/Plugins.jl/blob/d108fbb9fe3b7603131db4c238c2f44514723161/src/assembled_types.jl#LL4-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Plugins.MutableStruct" href="#Plugins.MutableStruct"><code>Plugins.MutableStruct</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct MutableStruct &lt;: TemplateStyle end</code></pre><p>Plugin-assembled types marked as <code>MutableStruct</code> will be generated as a <code>mutable struct</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tisztamo/Plugins.jl/blob/d108fbb9fe3b7603131db4c238c2f44514723161/src/assembled_types.jl#LL11-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Plugins.Plugin" href="#Plugins.Plugin"><code>Plugins.Plugin</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">abstract type Plugin</code></pre><p>Provides default implementations of lifecycle hooks.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tisztamo/Plugins.jl/blob/d108fbb9fe3b7603131db4c238c2f44514723161/src/Plugins.jl#LL9-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Plugins.PluginStack" href="#Plugins.PluginStack"><code>Plugins.PluginStack</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">PluginStack(plugins, hookfns = [])</code></pre><p>Manages the plugins loaded into an application.</p><p>It provides fast access to the plugins by symbol, e.g. <code>pluginstack[:logger]</code>. Collection methods and iteration interface are implemented.</p><p>The pluginstack is created from a list of plugins, and optionally a list of hook functions. If hook functions are provided, the <code>hooks()</code>` function can be called to</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tisztamo/Plugins.jl/blob/d108fbb9fe3b7603131db4c238c2f44514723161/src/Plugins.jl#LL66-L76">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Plugins.TemplateStyle-Tuple{Type}" href="#Plugins.TemplateStyle-Tuple{Type}"><code>Plugins.TemplateStyle</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">TemplateStyle(::Type) = MutableStruct()</code></pre><p>Trait to select the template used for plugin-assembled types</p><p>Use <a href="#Plugins.MutableStruct"><code>MutableStruct</code></a> (default), <a href="#Plugins.ImmutableStruct"><code>ImmutableStruct</code></a>, or subtype it when you want to create your own template.</p><p>#Examples</p><p>Assembling immutable structs:</p><pre><code class="language-julia">abstract type DebugInfo end
Plugins.TemplateStyle(::Type{DebugInfo}) = Plugins.ImmutableStruct()</code></pre><p>Defining your own template (see also  <a href="#Plugins.typedef"><code>typedef</code></a> ):</p><pre><code class="language-julia">struct CustomTemplate &lt;: Plugins.TemplateStyle end
Plugins.TemplateStyle(::Type{State}) = CustomTemplate()</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tisztamo/Plugins.jl/blob/d108fbb9fe3b7603131db4c238c2f44514723161/src/assembled_types.jl#LL18-L41">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Plugins.customfield-Tuple{Plugin,Type,Vararg{Any,N} where N}" href="#Plugins.customfield-Tuple{Plugin,Type,Vararg{Any,N} where N}"><code>Plugins.customfield</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">customfield(plugin::Plugin, abstract_type::Type, args...)</code></pre><p>Provide field specifications to plugin-assembled types.</p><p>Using this lifecycle hook the system can define custom plugin-assembled types (typically structs) based on field specifications provided by plugins. E.g. an error type can be extended with debug information.</p><p>A plugin can provide zero or one field to every assembled type. To provide a field, return a <a href="#Plugins.FieldSpec"><code>FieldSpec</code></a>.</p><p>The assembled type will be a subtype of <code>abstract_type</code>. To allow differently configured systems to run in the same Julia session, new types may be assembled for every instance of the system.</p><div class="admonition is-warning"><header class="admonition-header">Metaprogramming may make you unhappy</header><div class="admonition-body"><p>Although plugin-assmebled types are designed to help doing metaprogramming in a controlled fashion, it is usually better to use non-meta solutions instead. E.g. Store plugin state inside the plugin, collect data from multiple plugins using lifecycle hooks, etc.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tisztamo/Plugins.jl/blob/d108fbb9fe3b7603131db4c238c2f44514723161/src/Plugins.jl#LL43-L63">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Plugins.customtype" href="#Plugins.customtype"><code>Plugins.customtype</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">customtype(stack::PluginStack, typename::Symbol, abstract_type::Type, target_module::Module = Main; unique_name = true)</code></pre><p>Assemble a type with fields provided by the plugins in <code>stack</code>.</p><p><code>abstract_type</code> will be the supertype of the assembled type.</p><p>If <code>unique_name</code> == <code>true</code>, then <code>typename</code> will be suffixed with a structure-dependent id. The  id is generated as a hash of the evaluated expression (with the :TYPE_NAME placeholder used instead of the name), meaning that for the same id will be generated for a given type when the same plugins with the same source code are loaded.</p><p><strong>Examples</strong></p><p>Assembling a type <code>AppStateImpl &lt;: AppState</code> and parametrizing the app with it. </p><pre><code class="language-julia">abstract type AppState end

mutable struct CustomFieldsApp{TCustomState}
    state::TCustomState
    function CustomFieldsApp(plugins, hookfns, stateargs...)
        stack = PluginStack(plugins, hookfns)
        state_type = customtype(stack, :AppStateImpl, AppState)
        return new{state_type}(Base.invokelatest(state_type, stateargs...))
    end
end</code></pre><div class="admonition is-info"><header class="admonition-header">The need for `invokelatest`</header><div class="admonition-body"><p>We need to use <code>invokelatest</code> to instantiate a newly generated type. To use  the generated type normally, first you have to allow control flow to go to the top-level scope after the type was generated. See also the <a href="https://docs.julialang.org/en/v1/manual/methods/#Redefining-Methods">docs</a></p></div></div><div class="admonition is-warning"><header class="admonition-header">Antipattern</header><div class="admonition-body"><p>Assembling state types is an antipattern, because plugins can have their own state. (This may provide better performance in a few cases though) Assembled types can make your code less readable, use them sparingly!</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tisztamo/Plugins.jl/blob/d108fbb9fe3b7603131db4c238c2f44514723161/src/assembled_types.jl#LL104-L140">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Plugins.hook_cache-Tuple{Any,Any}" href="#Plugins.hook_cache-Tuple{Any,Any}"><code>Plugins.hook_cache</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">hook_cache(stack::PluginStack, hookfns)
hook_cache(plugins, hookfns)</code></pre><p>Create a cache of <code>HookList</code>s for a PluginStack or from lists of plugins and hook functions.</p><p>Returns a NamedTuple with an entry for every handler.</p><p><strong>Examples</strong></p><pre><code class="language-julia">cache = hook_cache([Plugin1(), Plugin2()], [hook1, hook2])
cache.hook1()</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tisztamo/Plugins.jl/blob/d108fbb9fe3b7603131db4c238c2f44514723161/src/Plugins.jl#LL190-L204">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Plugins.hooklist-Tuple{Any,Any}" href="#Plugins.hooklist-Tuple{Any,Any}"><code>Plugins.hooklist</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function hooklist(plugins, hookfn)</code></pre><p>Create a HookList which allows fast, inlinable call to the merged implementations of <code>hookfn</code> by the given plugins.</p><p>A plugin of type <code>TPlugin</code> found in plugins will be referenced in the resulting HookList if there is a method that matches the following signature: <code>hookfn(::TPlugin, ...)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tisztamo/Plugins.jl/blob/d108fbb9fe3b7603131db4c238c2f44514723161/src/Plugins.jl#LL148-L156">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Plugins.hooks" href="#Plugins.hooks"><code>Plugins.hooks</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">hooks(app)
hooks(pluginstack::PluginStack)</code></pre><p>Create or get a hook cache for <code>stack</code>.</p><p>The first form can be used when <code>pluginstack</code> is stored in <code>app.plugins</code> (the recommended pattern).</p><p>When this function is called first time on a <code>PluginStack</code>, the hooks cache will be created by calling <code>hook_cache()</code>, and stored in <code>pluginstack</code> for quick access later.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tisztamo/Plugins.jl/blob/d108fbb9fe3b7603131db4c238c2f44514723161/src/Plugins.jl#LL169-L179">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Plugins.setup!-Tuple{Plugin,Vararg{Any,N} where N}" href="#Plugins.setup!-Tuple{Plugin,Vararg{Any,N} where N}"><code>Plugins.setup!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">setup!(plugin, deps, args...)</code></pre><p>Initialize the plugin with the given dependencies and arguments (e.g. shared state).</p><p>This lifecycle hook will be called when the application loads a plugin. Plugins.jl does not (yet) helps with this, application developers should do it manually, right after the PluginStack was created, before the hook_cache() call.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tisztamo/Plugins.jl/blob/d108fbb9fe3b7603131db4c238c2f44514723161/src/Plugins.jl#LL23-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Plugins.shutdown!-Tuple{Plugin,Vararg{Any,N} where N}" href="#Plugins.shutdown!-Tuple{Plugin,Vararg{Any,N} where N}"><code>Plugins.shutdown!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">shutdown!(plugin, sharedstate)</code></pre><p>Shut down the plugin.</p><p>This lifecycle hook will be called when the application unloads a plugin, e.g. before the application exits. Plugins.jl does not (yet) helps with this, application developers should do it manually.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tisztamo/Plugins.jl/blob/d108fbb9fe3b7603131db4c238c2f44514723161/src/Plugins.jl#LL33-L40">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Plugins.symbol-Tuple{Plugin}" href="#Plugins.symbol-Tuple{Plugin}"><code>Plugins.symbol</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">symbol(plugin)</code></pre><p>Return the unique Symbol of this plugin if it exports an API to other plugins.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tisztamo/Plugins.jl/blob/d108fbb9fe3b7603131db4c238c2f44514723161/src/Plugins.jl#LL16-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Plugins.typedef" href="#Plugins.typedef"><code>Plugins.typedef</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">typedef(templatestyle, spec::TypeSpec)::Expr</code></pre><p>Return an expression defining a type.</p><p>Implement it for your own template styles. More info in the <a href="https://github.com/tisztamo/Plugins.jl/blob/master/test/customfields.jl">tests</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tisztamo/Plugins.jl/blob/d108fbb9fe3b7603131db4c238c2f44514723161/src/assembled_types.jl#LL80-L87">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../repo/">« Repo</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Monday 8 February 2021 16:22">Monday 8 February 2021</span>. Using Julia version 1.3.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
