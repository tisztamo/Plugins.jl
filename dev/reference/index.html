<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Reference · Plugins.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.044/juliamono.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="Plugins.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">Plugins.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction</a></li><li><a class="tocitem" href="../tutorial/">Tutorial</a></li><li><a class="tocitem" href="../features/">Features and usage</a></li><li><a class="tocitem" href="../guide/">Guide</a></li><li><a class="tocitem" href="../repo/">Repo</a></li><li class="is-active"><a class="tocitem" href>Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Reference</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/tisztamo/Plugins.jl/blob/master/docs/src/reference.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Reference"><a class="docs-heading-anchor" href="#Reference">Reference</a><a id="Reference-1"></a><a class="docs-heading-anchor-permalink" href="#Reference" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="Plugins.Configuration" href="#Plugins.Configuration"><code>Plugins.Configuration</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type Configuration &lt;: ContextStage end</code></pre><p>Stage that potentially changes the behavior of the program without evaluating previously unknown code.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tisztamo/Plugins.jl/blob/c8cdaf8c0a8265878a1bae25f4db28a6d4325f8f/src/stages.jl#LL45-L50">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Plugins.ContextStage" href="#Plugins.ContextStage"><code>Plugins.ContextStage</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type ContextStage &lt;: Stage end</code></pre><p>Stage technique that generates a new stage context type, which can be used for dispatching or in <code>@generated</code> functions. Assembled types may be regenerated during a <code>ContextStage</code>, depending on TODO.</p><p>A context stage does not create a new world but run in the same world than the previous stage.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tisztamo/Plugins.jl/blob/c8cdaf8c0a8265878a1bae25f4db28a6d4325f8f/src/stages.jl#LL18-L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Plugins.EvalStage" href="#Plugins.EvalStage"><code>Plugins.EvalStage</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type EvalStage &lt;: Stage end</code></pre><p>Stage technique that runs in a new world and generates a new stage context type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tisztamo/Plugins.jl/blob/c8cdaf8c0a8265878a1bae25f4db28a6d4325f8f/src/stages.jl#LL30-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Plugins.Extension" href="#Plugins.Extension"><code>Plugins.Extension</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type Extension &lt;: EvalStage end</code></pre><p>Stage that evaluates previously unknown code, e.g. loads new plugins.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tisztamo/Plugins.jl/blob/c8cdaf8c0a8265878a1bae25f4db28a6d4325f8f/src/stages.jl#LL63-L68">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Plugins.FieldSpec" href="#Plugins.FieldSpec"><code>Plugins.FieldSpec</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">FieldSpec(name, type::Type, constructor::Union{Function, DataType} = type)</code></pre><p>Field specification for plugin-assembled types.</p><p>Note that every field of an assembled type will be constructed with the same arguments.  Possibly The constructor will be called when the system </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tisztamo/Plugins.jl/blob/c8cdaf8c0a8265878a1bae25f4db28a6d4325f8f/src/assembled_types.jl#LL48-L55">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Plugins.HookList" href="#Plugins.HookList"><code>Plugins.HookList</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">HookList{TNext, THandler, TPlugin}</code></pre><p>Provides fast, inlinable call to the implementations of a specific hook.</p><p>You can get a HookList by calling <code>hooklist()</code> directly, or using <code>hooks()</code>.</p><p>The <code>HookList</code> can be called with arbitrary number of extra arguments. If any of the plugins referenced in the list fails to handle the extra arguments, the call will raise a <code>MethodError</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tisztamo/Plugins.jl/blob/c8cdaf8c0a8265878a1bae25f4db28a6d4325f8f/src/hooks.jl#LL1-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Plugins.ImmutableStruct" href="#Plugins.ImmutableStruct"><code>Plugins.ImmutableStruct</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct ImmutableStruct &lt;: TemplateStyle end</code></pre><p>Plugin-assembled types marked as <code>ImmutableStruct</code> will be generated as a <code>struct</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tisztamo/Plugins.jl/blob/c8cdaf8c0a8265878a1bae25f4db28a6d4325f8f/src/assembled_types.jl#LL3-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Plugins.Initialization" href="#Plugins.Initialization"><code>Plugins.Initialization</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type Initialization &lt;: EvalStage end</code></pre><p>A classical Stage that runs before the normal operation of the program.</p><p>Multiple initialization stages may run, but only before the first non-Initialization stage.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tisztamo/Plugins.jl/blob/c8cdaf8c0a8265878a1bae25f4db28a6d4325f8f/src/stages.jl#LL53-L60">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Plugins.MutableStruct" href="#Plugins.MutableStruct"><code>Plugins.MutableStruct</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct MutableStruct &lt;: TemplateStyle end</code></pre><p>Plugin-assembled types marked as <code>MutableStruct</code> will be generated as a <code>mutable struct</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tisztamo/Plugins.jl/blob/c8cdaf8c0a8265878a1bae25f4db28a6d4325f8f/src/assembled_types.jl#LL10-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Plugins.Optimization" href="#Plugins.Optimization"><code>Plugins.Optimization</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type Optimization &lt;: ContextStage end</code></pre><p>Stage that does not change the functional behavior of the program, only its performance characteristics.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tisztamo/Plugins.jl/blob/c8cdaf8c0a8265878a1bae25f4db28a6d4325f8f/src/stages.jl#LL37-L42">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Plugins.Plugin" href="#Plugins.Plugin"><code>Plugins.Plugin</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type Plugin</code></pre><p>Provides default implementations of lifecycle hooks.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tisztamo/Plugins.jl/blob/c8cdaf8c0a8265878a1bae25f4db28a6d4325f8f/src/Plugins.jl#LL10-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Plugins.PluginStack" href="#Plugins.PluginStack"><code>Plugins.PluginStack</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">PluginStack(plugins, hookfns = [])</code></pre><p>Manages the plugins loaded into an application.</p><p>It provides fast access to the plugins by symbol, e.g. <code>pluginstack[:logger]</code>. Collection methods and iteration interface are implemented.</p><p>The pluginstack is created from a list of plugins, and optionally a list of hook functions. If hook functions are provided, the <code>hooks()</code>` function can be called to</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tisztamo/Plugins.jl/blob/c8cdaf8c0a8265878a1bae25f4db28a6d4325f8f/src/Plugins.jl#LL17-L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Plugins.Stage" href="#Plugins.Stage"><code>Plugins.Stage</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type Stage end</code></pre><p>Base type that represents a step of iterated staging.</p><p>Iterated staging allows the program to repeatedly self-recompile its parts. The first iterations are</p><p><code>Stage</code> is the root of a layered type hierarchy:</p><ul><li>Direct subtypes of it (ContextStage, EvalStage) represent staging</li></ul><p>techniques available in Julia.</p><ul><li>Downstream subtypes represent means of staging:</li></ul><p>Initialization, Extension, Optimization, Configuration.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tisztamo/Plugins.jl/blob/c8cdaf8c0a8265878a1bae25f4db28a6d4325f8f/src/stages.jl#LL1-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Plugins.TemplateStyle-Tuple{Type}" href="#Plugins.TemplateStyle-Tuple{Type}"><code>Plugins.TemplateStyle</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">TemplateStyle(::Type) = MutableStruct()</code></pre><p>Trait to select the template used for plugin-assembled types</p><p>Use <a href="#Plugins.MutableStruct"><code>MutableStruct</code></a> (default), <a href="#Plugins.ImmutableStruct"><code>ImmutableStruct</code></a>, or subtype it when you want to create your own template.</p><p>#Examples</p><p>Assembling immutable structs:</p><pre><code class="language-julia hljs">abstract type DebugInfo end
Plugins.TemplateStyle(::Type{DebugInfo}) = Plugins.ImmutableStruct()</code></pre><p>Defining your own template (see also  <a href="#Plugins.typedef"><code>typedef</code></a> ):</p><pre><code class="language-julia hljs">struct CustomTemplate &lt;: Plugins.TemplateStyle end
Plugins.TemplateStyle(::Type{State}) = CustomTemplate()</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tisztamo/Plugins.jl/blob/c8cdaf8c0a8265878a1bae25f4db28a6d4325f8f/src/assembled_types.jl#LL17-L40">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Plugins.autoregister" href="#Plugins.autoregister"><code>Plugins.autoregister</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">function autoregister(base=Plugin)</code></pre><p>Find and register every concrete subtype of &#39;base&#39; as a Plugin</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tisztamo/Plugins.jl/blob/c8cdaf8c0a8265878a1bae25f4db28a6d4325f8f/src/deps.jl#LL35-L39">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Plugins.customfield-Tuple{Plugin, Type, Vararg{Any}}" href="#Plugins.customfield-Tuple{Plugin, Type, Vararg{Any}}"><code>Plugins.customfield</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">customfield(plugin::Plugin, abstract_type::Type, args...) = nothing</code></pre><p>Provide field specifications to plugin-assembled types.</p><p>Using this lifecycle hook the system can define custom plugin-assembled types (typically structs) based on field specifications provided by plugins. E.g. an error type can be extended with debug information.</p><p>A plugin can provide zero or one field to every assembled type. To provide a field, return a <a href="#Plugins.FieldSpec"><code>FieldSpec</code></a>.</p><p>The assembled type will be a subtype of <code>abstract_type</code>. To allow differently configured systems to run in the same Julia session, new types may be assembled for every instance of the system.</p><div class="admonition is-warning"><header class="admonition-header">Metaprogramming may make you unhappy</header><div class="admonition-body"><p>Although plugin-assmebled types are designed to help doing metaprogramming in a controlled fashion, it is usually better to use non-meta solutions instead. E.g. Store plugin state inside the plugin, collect data from multiple plugins using lifecycle hooks, etc.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tisztamo/Plugins.jl/blob/c8cdaf8c0a8265878a1bae25f4db28a6d4325f8f/src/lifecycle.jl#LL29-L49">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Plugins.customtype" href="#Plugins.customtype"><code>Plugins.customtype</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">customtype(stack::PluginStack, typename::Symbol, abstract_type::Type, target_module::Module = Main; unique_name = true)</code></pre><p>Assemble a type with fields provided by the plugins in <code>stack</code>.</p><p><code>abstract_type</code> will be the supertype of the assembled type.</p><p>If <code>unique_name</code> == <code>true</code>, then <code>typename</code> will be suffixed with a structure-dependent id. The  id is generated as a hash of the evaluated expression (with the :TYPE_NAME placeholder used instead of the name), meaning that for the same id will be generated for a given type when the same plugins with the same source code are loaded.</p><p><strong>Examples</strong></p><p>Assembling a type <code>AppStateImpl &lt;: AppState</code> and parametrizing the app with it. </p><pre><code class="language-julia hljs">abstract type AppState end

mutable struct CustomFieldsApp{TCustomState}
    state::TCustomState
    function CustomFieldsApp(plugins, hookfns, stateargs...)
        stack = PluginStack(plugins, hookfns)
        state_type = customtype(stack, :AppStateImpl, AppState)
        return new{state_type}(Base.invokelatest(state_type, stateargs...))
    end
end</code></pre><div class="admonition is-info"><header class="admonition-header">The need for `invokelatest`</header><div class="admonition-body"><p>We need to use <code>invokelatest</code> to instantiate a newly generated type. To use  the generated type normally, first you have to allow control flow to go to the top-level scope after the type was generated. See also the <a href="https://docs.julialang.org/en/v1/manual/methods/#Redefining-Methods">docs</a></p></div></div><div class="admonition is-warning"><header class="admonition-header">Antipattern</header><div class="admonition-body"><p>Assembling state types is an antipattern, because plugins can have their own state. (This may provide better performance in a few cases though) Assembled types can make your code less readable, use them sparingly!</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tisztamo/Plugins.jl/blob/c8cdaf8c0a8265878a1bae25f4db28a6d4325f8f/src/assembled_types.jl#LL103-L139">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Plugins.deps-Tuple{Any}" href="#Plugins.deps-Tuple{Any}"><code>Plugins.deps</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Plugins.deps(::Type{T}) = Type[] # where T is your plugin type</code></pre><p>Add a method to declare your dependencies.</p><p>The plugin type must have a constructor accepting an instance of every of their dependencies.</p><p><strong>Examples</strong></p><p>abstract type InterfaceLeft end struct ImplLeft &lt;: InterfaceLeft end</p><p>abstract type InterfaceRight end struct ImplRight &lt;: InterfaceRight end</p><p>Plugins.deps(::Type{ImplLeft}) = [ImplRight]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tisztamo/Plugins.jl/blob/c8cdaf8c0a8265878a1bae25f4db28a6d4325f8f/src/deps.jl#LL15-L31">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Plugins.enter_stage-Tuple{Plugin, Any, Vararg{Any}}" href="#Plugins.enter_stage-Tuple{Plugin, Any, Vararg{Any}}"><code>Plugins.enter_stage</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">enter_stage(plugin::Plugin, stage::Stage, args...)</code></pre><p>Lifecycle hook marking the start of the next stage.</p><p>Types are reasssembled at this point. If <code>stage isa EvalStage</code>, then the world is already updated. (execution reached toplevel)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tisztamo/Plugins.jl/blob/c8cdaf8c0a8265878a1bae25f4db28a6d4325f8f/src/lifecycle.jl#LL81-L89">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Plugins.hook_cache-Tuple{Any, Any}" href="#Plugins.hook_cache-Tuple{Any, Any}"><code>Plugins.hook_cache</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">hook_cache(stack::PluginStack, hookfns)
hook_cache(plugins, hookfns)</code></pre><p>Create a cache of <code>HookList</code>s for a PluginStack or from lists of plugins and hook functions.</p><p>Returns a NamedTuple with an entry for every handler.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">cache = hook_cache([Plugin1(), Plugin2()], [hook1, hook2])
cache.hook1()</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tisztamo/Plugins.jl/blob/c8cdaf8c0a8265878a1bae25f4db28a6d4325f8f/src/hooks.jl#LL88-L102">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Plugins.hooklist-Tuple{Any, Any}" href="#Plugins.hooklist-Tuple{Any, Any}"><code>Plugins.hooklist</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function hooklist(plugins, hookfn)</code></pre><p>Create a HookList which allows fast, inlinable call to the merged implementations of <code>hookfn</code> by the given plugins.</p><p>A plugin of type <code>TPlugin</code> found in plugins will be referenced in the resulting HookList if there is a method that matches the following signature: <code>hookfn(::TPlugin, ...)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tisztamo/Plugins.jl/blob/c8cdaf8c0a8265878a1bae25f4db28a6d4325f8f/src/hooks.jl#LL46-L54">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Plugins.hooks" href="#Plugins.hooks"><code>Plugins.hooks</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">hooks(app)
hooks(pluginstack::PluginStack)</code></pre><p>Create or get a hook cache for <code>stack</code>.</p><p>The first form can be used when <code>pluginstack</code> is stored in <code>app.plugins</code> (the recommended pattern).</p><p>When this function is called first time on a <code>PluginStack</code>, the hooks cache will be created by calling <code>hook_cache()</code>, and stored in <code>pluginstack</code> for quick access later.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tisztamo/Plugins.jl/blob/c8cdaf8c0a8265878a1bae25f4db28a6d4325f8f/src/hooks.jl#LL67-L77">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Plugins.leave_stage-Tuple{Plugin, Any, Vararg{Any}}" href="#Plugins.leave_stage-Tuple{Plugin, Any, Vararg{Any}}"><code>Plugins.leave_stage</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">leave_stage(plugin::Plugin, stage::Stage, nextstage::Stage, args...)</code></pre><p>Lifecycle hook marking the end of a stage.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tisztamo/Plugins.jl/blob/c8cdaf8c0a8265878a1bae25f4db28a6d4325f8f/src/lifecycle.jl#LL92-L96">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Plugins.prepare_stage-Tuple{Plugin, Any, Vararg{Any}}" href="#Plugins.prepare_stage-Tuple{Plugin, Any, Vararg{Any}}"><code>Plugins.prepare_stage</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">prepare_stage(plugin::Plugin, stage::Stage)</code></pre><p>Lifecycle hook to prepare the plugin for the next stage. If the stage is an <code>EvalStage</code> and the plugin needs to evaluate code, this is the point to do it.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tisztamo/Plugins.jl/blob/c8cdaf8c0a8265878a1bae25f4db28a6d4325f8f/src/lifecycle.jl#LL72-L78">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Plugins.request_stage-Tuple{Plugin, Vararg{Any}}" href="#Plugins.request_stage-Tuple{Plugin, Vararg{Any}}"><code>Plugins.request_stage</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">request_stage(plugin::Plugin, args...)::Stage</code></pre><p>Request a new stage iteration by returning a Stage representing it.</p><p>This lifecycle hook will be called repeatedly to ask plugins their wish to stage. If a plugin returns a <code>Stage</code> instance and the request is accepted, the stage will start immediately.</p><p>If more than one plugins ask for staging, their request will be merged if possible and only one stage will run. If the stages are incompatible, meaning that different sets of plugins handle the <code>prepeare</code> hook of the stages, then only a compatible subset of them will run.</p><p>Plugins should continue requesting staging until their wish gets fulfilled.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tisztamo/Plugins.jl/blob/c8cdaf8c0a8265878a1bae25f4db28a6d4325f8f/src/lifecycle.jl#LL52-L69">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Plugins.setup!-Tuple{Plugin, Vararg{Any}}" href="#Plugins.setup!-Tuple{Plugin, Vararg{Any}}"><code>Plugins.setup!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">setup!(plugin, deps, args...)</code></pre><p>Initialize the plugin with the given dependencies and arguments (e.g. shared state).</p><p>This lifecycle hook will be called when the application loads a plugin. Plugins.jl does not (yet) helps with this, application developers should do it manually, right after the PluginStack was created, before the hook_cache() call.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tisztamo/Plugins.jl/blob/c8cdaf8c0a8265878a1bae25f4db28a6d4325f8f/src/lifecycle.jl#LL8-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Plugins.shutdown!-Tuple{Plugin, Vararg{Any}}" href="#Plugins.shutdown!-Tuple{Plugin, Vararg{Any}}"><code>Plugins.shutdown!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">shutdown!(plugin, args...)</code></pre><p>Shut down the plugin.</p><p>This lifecycle hook will be called when the application unloads a plugin, e.g. before the application exits. Plugins.jl does not (yet) helps with this, application developers should do it manually.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tisztamo/Plugins.jl/blob/c8cdaf8c0a8265878a1bae25f4db28a6d4325f8f/src/lifecycle.jl#LL18-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Plugins.symbol-Tuple{Plugin}" href="#Plugins.symbol-Tuple{Plugin}"><code>Plugins.symbol</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">symbol(plugin)</code></pre><p>Return the per-PluginStack unique Symbol of this plugin if it exports a &quot;late-bind&quot; runtime API to other plugins.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tisztamo/Plugins.jl/blob/c8cdaf8c0a8265878a1bae25f4db28a6d4325f8f/src/lifecycle.jl#LL1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Plugins.typedef" href="#Plugins.typedef"><code>Plugins.typedef</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">typedef(templatestyle, spec::TypeSpec)::Expr</code></pre><p>Return an expression defining a type.</p><p>Implement it for your own template styles. More info in the <a href="https://github.com/tisztamo/Plugins.jl/blob/master/test/customfields.jl">tests</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tisztamo/Plugins.jl/blob/c8cdaf8c0a8265878a1bae25f4db28a6d4325f8f/src/assembled_types.jl#LL79-L86">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../repo/">« Repo</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.16 on <span class="colophon-date" title="Friday 22 April 2022 13:25">Friday 22 April 2022</span>. Using Julia version 1.7.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
