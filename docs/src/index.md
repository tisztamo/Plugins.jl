# Introduction

A plugin is a chunk of code that extends the functionality of a system. It is much like a component, as it has its own lifecycle and it reacts to events generated by the system. A plugin-based architecture can be useful to develop maintainable software, but its dynamic nature introduces a performance penalty that is not always acceptable.

Plugins.jl helps by analyzing the plugins loaded into the system and generating types to leverage the "Just Ahead Of Time" compilation of Julia, thus allowing full optimization. Execution of plugin code can be just as performant as a manually composed system. Inlinable hook implementations will be merged into a single function body, and non-implementing plugins are skipped with zero overhead.

## Plugin-based architecture

A plugin implements so-called hooks: functions that the system will call at specific points of its inner life. You can think of hooks as they were event handlers, when the event source is the "base system".

The system is configured with an array of plugins. If multiple plugins implement the same hook, they will be called in their order, with any plugin able to halt the processing by simply returning `true`.

Plugins have their own state, but they can access a shared state/configuration, and they can also publish an API by registering a symbol that other plugins can search for.

